class Vec{constructor(x,y,z,w){this.x=x||0;this.y=y||0;if(z!==undefined)this.z=z;if(w!==undefined)this.w=w}}export class Vec2 extends Vec{constructor(x,y){super(x,y)}static add(a,b){return new Vec2(a.x+b.x,a.y+b.y)}static angleBetween(a,b){const MA=a.magnitude;const MB=b.magnitude;if(MA===0||MB===0){console.error("Cannot divide by zero.");return NaN}return Math.acos(Vec2.dot(a,b)/(MA*MB))}static distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y}static fromCopy(a){return new Vec2({...a}.x,{...a}.y)}static fromPolarCoords(radius,phi){return new Vec2(radius*Math.cos(phi),radius*Math.sin(phi))}static project(a,b){const PM=a.magnitude*Math.cos(Vec2.angleBetween(a,b));const P=Vec2.fromCopy(b);P.normalize();P.scale(PM);return P}static subtract(a,b){return new Vec2(a.x-b.x,a.y-b.y)}get angleX(){return Math.atan2(this.y,this.x)}get angleY(){return Math.atan2(this.x,this.y)}get magnitude(){return Math.sqrt(this.x**2+this.y**2)}get xy(){return[this.x,this.y]}set limit(max){if(this.magnitude>max){this.normalize();this.scale(max)}return this}set magnitude(m){this.normalize();this.scale(m);return this}set xy(x,y){this.x=x;this.y=y}add(a){this.x=this.x+a.x;this.y=this.y+a.y;return this}clamp(max,min){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x={...a}.x;this.y={...a}.y;return this}normalize(){let m=this.magnitude;if(m===0)m=1;else m=1/m;this.x=this.x*m;this.y=this.y*m;return this}rotateAxisZ(phi){[this.x,this.y]=[this.x*Math.cos(phi)-this.y*Math.sin(phi),this.x*Math.sin(phi)+this.y*Math.cos(phi)];return this}scale(val){this.x=this.x*val;this.y=this.y*val;return this}subtract(a){this.x=this.x-a.x;this.y=this.y-a.y;return this}}export class Vec3 extends Vec{constructor(x,y,z){super(x,y,z||0)}static add(a,b){return new Vec3(a.x+b.x,a.y+b.y,a.z+b.z)}static angleBetween(a,b){const MA=a.magnitude;const MB=b.magnitude;if(MA===0||MB===0){console.error("Cannot divide by zero.");return NaN}return Math.acos(Vec3.dot(a,b)/(MA*MB))}static cross(a,b){return new Vec3(a.y*b.z-b.y*a.z,a.z*b.x-b.z*a.x,a.x*b.y-b.x*a.y)}static distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+(a.z-b.z)**2)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y),Math.abs(a.z-b.z))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y)+Math.abs(a.z-b.z))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e+Math.abs(a.z-b.z)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z}static fromCopy(a){return new Vec3({...a}.x,{...a}.y,{...a}.z)}static fromCylindricalCoords(radius,phi,z){return new Vec3(radius*Math.cos(phi),radius*Math.sin(phi),z)}static fromSphericalCoords(radius,phi,theta){return new Vec3(radius*Math.sin(theta)*Math.cos(phi),radius*Math.sin(theta)*Math.sin(phi),radius*Math.cos(theta))}static project(a,b){const PM=a.magnitude*Math.cos(Vec3.angleBetween(a,b));const P=Vec3.fromCopy(b);P.normalize();P.scale(PM);return P}static subtract(a,b){return new Vec3(a.x-b.x,a.y-b.y,a.z-b.z)}get angleX(){return Math.atan2(this.y,this.x)}get angleY(){return Math.atan2(this.x,this.y)}get angleZ(){return Math.acos(this.z/this.magnitude)}get b(){return this.z}get g(){return this.y}get magnitude(){return Math.sqrt(this.x**2+this.y**2+this.z**2)}get r(){return this.x}get rgb(){return[this.x,this.y,this.z]}get xyz(){return[this.x,this.y,this.z]}set b(b){this.z=b}set g(g){this.y=g}set limit(max){if(this.magnitude>max){this.normalize();this.scale(max)}return this}set magnitude(m){this.normalize();this.scale(m);return this}set r(r){this.x=r}set rgb(r,g,b){this.x=r;this.y=g;this.z=b}set xyz(x,y,z){this.x=x;this.y=y;this.z=z}add(a){this.x=this.x+a.x;this.y=this.y+a.y;this.z=this.z+a.z;return this}clamp(max,min){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x={...a}.x;this.y={...a}.y;this.z={...a}.z;return this}normalize(){let m=this.magnitude;if(m===0)m=1;else m=1/m;this.x=this.x*m;this.y=this.y*m;this.z=this.z*m;return this}rotateAxisX(phi){[this.y,this.z]=[this.z*Math.cos(phi)-this.z*Math.sin(phi),this.z*Math.sin(phi)+this.z*Math.cos(phi)];return this}rotateAxisY(phi){[this.x,this.z]=[this.x*Math.cos(phi)-this.z*Math.sin(phi),-this.x*Math.sin(phi)+this.z*Math.cos(phi)];return this}rotateAxisZ(phi){[this.x,this.y]=[this.x*Math.cos(phi)-this.y*Math.sin(phi),this.x*Math.sin(phi)+this.y*Math.cos(phi)];return this}scale(val){this.x=this.x*val;this.y=this.y*val;this.z=this.z*val;return this}subtract(a){this.x=this.x-a.x;this.y=this.y-a.y;this.z=this.z-a.z;return this}}export class Vec4 extends Vec{constructor(x,y,z,w){super(x,y,z||0,w||0)}static add(a,b){return new Vec4(a.x+b.x,a.y+b.y,a.z+b.z,a.w+b.w)}static angleBetween(a,b){const MA=a.magnitude;const MB=b.magnitude;if(MA===0||MB===0){console.error("Cannot divide by zero.");return NaN}return Math.acos(Vec4.dot(a,b)/(MA*MB))}static distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+(a.z-b.z)**2+(a.w-b.w)**2)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y),Math.abs(a.z-b.z),Math.abs(a.w-b.w))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y)+Math.abs(a.z-b.z)+Math.abs(a.w-b.w))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e+Math.abs(a.z-b.z)**e+Math.abs(a.w-b.w)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w}static fromCopy(a){return new Vec4({...a}.x,{...a}.y,{...a}.z,{...a}.w)}static project(a,b){const PM=a.magnitude*Math.cos(Vec4.angleBetween(a,b));const P=Vec4.fromCopy(b);P.normalize();P.scale(PM);return P}static subtract(a,b){return new Vec4(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w)}get a(){return this.w}get angleX(){return Math.atan2(this.y,this.x)}get angleY(){return Math.atan2(this.x,this.y)}get angleZ(){return Math.acos(this.z/this.magnitude)}get b(){return this.z}get g(){return this.y}get magnitude(){return Math.sqrt(this.x**2+this.y**2+this.z**2+this.w**2)}get r(){return this.x}get rgba(){return[this.x,this.y,this.z,this.w]}get xyzw(){return[this.x,this.y,this.z,this.w]}set a(a){this.w=a}set b(b){this.z=b}set g(g){this.y=g}set limit(max){if(this.magnitude>max){this.normalize();this.scale(max)}return this}set magnitude(m){this.normalize();this.scale(m);return this}set r(r){this.x=r}set rgba(r,g,b,a){this.x=r;this.y=g;this.z=b;this.w=a}set xyzw(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w}add(a){this.x=this.x+a.x;this.y=this.y+a.y;this.z=this.z+a.z;this.w=this.w+a.w;return this}clamp(max,min){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x={...a}.x;this.y={...a}.y;this.z={...a}.z;this.w={...a}.w;return this}normalize(){let m=this.magnitude;if(m===0)m=1;else m=1/m;this.x=this.x*m;this.y=this.y*m;this.z=this.z*m;this.w=this.w*m;return this}scale(val){this.x=this.x*val;this.y=this.y*val;this.z=this.z*val;this.w=this.w*val;return this}subtract(a){this.x=this.x-a.x;this.y=this.y-a.y;this.z=this.z-a.z;this.w=this.w-a.w;return this}}
