export class Vec2 { constructor(a, b) { this.x = a, this.y = b } static add(c, a) { return new Vec2(c.x + a.x, c.y + a.y) } static angleBetween(c, a) { const b = c.magnitude, d = a.magnitude; return 0 === b || 0 === d ? void 0 : Math.acos(Vec2.dot(c, a) / (b * d)) } static distance(c, a) { const b = c.x - a.x, d = c.y - a.y; return Math.sqrt(b * b + d * d) } static distanceChebyshev(c, a) { return Math.max(Math.abs(c.x - a.x), Math.abs(c.y - a.y)) } static distanceManhattan(c, a) { return Math.sqrt(Math.abs(c.x - a.x) + Math.abs(c.y - a.y)) } static distanceMinkowski(c, a, b) { return (Math.abs(c.x - a.x) ** b + Math.abs(c.y - a.y) ** b) ** (1 / b) } static dot(c, a) { return c.x * a.x + c.y * a.y } static fromCopy(b) { return new Vec2({ ...b }.x, { ...b }.y) } static fromPolarCoords(a, b) { return new Vec2(a * Math.cos(b), a * Math.sin(b)) } static project(c, a) { const b = c.magnitude * Math.cos(Vec2.angleBetween(c, a)), d = Vec2.fromCopy(a); return d.normalize(), d.scale(b), d } static subtract(c, a) { return new Vec2(c.x - a.x, c.y - a.y) } get angleX() { return Math.atan2(this.y, this.x) } get angleY() { return Math.atan2(this.x, this.y) } get magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y) } set limit(b) { this.magnitude > b && (this.normalize(), this.scale(b)) } set magnitude(b) { this.normalize(), this.scale(b) } add(b) { this.x += b.x, this.y += b.y } copy(b) { this.x = { ...b }.x, this.y = { ...b }.y } normalize() { let a = this.magnitude; 0 === a && (a = 1), this.x *= a, this.y *= a } scale(b) { this.x *= b, this.y *= b } subtract(b) { this.x -= b.x, this.y -= b.y } } export class Vec3 { constructor(a, b, c) { this.x = a, this.y = b, this.z = c } static add(c, a) { return new Vec3(c.x + a.x, c.y + a.y, c.z + a.z) } static angleBetween(c, a) { const b = c.magnitude, d = a.magnitude; return 0 === b || 0 === d ? void 0 : Math.acos(Vec3.dot(c, a) / (b * d)) } static cross(c, a) { return new Vec3(c.y * a.z - a.y * c.z, c.z * a.x - a.z * c.x, c.x * a.y - a.x * c.y) } static distance(c, a) { const b = c.x - a.x, d = c.y - a.y, e = c.z - a.z; return Math.sqrt(b * b + d * d + e * e) } static distanceChebyshev(c, a) { return Math.max(Math.abs(c.x - a.x), Math.abs(c.y - a.y), Math.abs(c.z - a.z)) } static distanceManhattan(c, a) { return Math.sqrt(Math.abs(c.x - a.x) + Math.abs(c.y - a.y) + Math.abs(c.z - a.z)) } static distanceMinkowski(c, a, b) { return (Math.abs(c.x - a.x) ** b + Math.abs(c.y - a.y) ** b + Math.abs(c.z - a.z) ** b) ** (1 / b) } static dot(c, a) { return c.x * a.x + c.y * a.y + c.z * a.z } static fromCopy(b) { return new Vec3({ ...b }.x, { ...b }.y, { ...b }.z) } static fromSphericalCoords(a, b, c) { return new Vec3(a * Math.cos(b) * Math.sin(c), a * Math.sin(b) * Math.sin(c), a * Math.cos(c)) } static project(c, a) { const b = c.magnitude * Math.cos(Vec3.angleBetween(c, a)), d = Vec3.fromCopy(a); return d.normalize(), d.scale(b), d } static subtract(c, a) { return new Vec3(c.x - a.x, c.y - a.y, c.z - a.z) } get angleX() { return Math.atan2(Math.sqrt(this.y ** 2 + this.z ** 2), this.x) } get angleY() { return Math.atan2(Math.sqrt(this.x ** 2 + this.z ** 2), this.y) } get angleZ() { return Math.atan2(Math.sqrt(this.x ** 2 + this.y ** 2), this.z) } get magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } set limit(b) { this.magnitude > b && (this.normalize(), this.scale(b)) } set magnitude(b) { this.normalize(), this.scale(b) } add(b) { this.x += b.x, this.y += b.y, this.z += b.z } copy(b) { this.x = { ...b }.x, this.y = { ...b }.y, this.z = { ...b }.z } normalize() { let a = this.magnitude; 0 === a && (a = 1), this.x *= a, this.y *= a, this.z *= a } scale(b) { this.x *= b, this.y *= b, this.z *= b } subtract(b) { this.x -= b.x, this.y -= b.y, this.z -= b.z } } export class Vec4 { constructor(a, b, c, d) { this.x = a, this.y = b, this.z = c, this.w = d } static add(c, a) { return new Vec4(c.x + a.x, c.y + a.y, c.z + a.z, c.w + a.w) } static angleBetween(c, a) { const b = c.magnitude, d = a.magnitude; return 0 === b || 0 === d ? void 0 : Math.acos(Vec4.dot(c, a) / (b * d)) } static distance(c, a) { const b = c.x - a.x, d = c.y - a.y, e = c.z - a.z, f = c.w - a.w; return Math.sqrt(b * b + d * d + e * e + f * f) } static distanceChebyshev(c, a) { return Math.max(Math.abs(c.x - a.x), Math.abs(c.y - a.y), Math.abs(c.z - a.z), Math.abs(c.w - a.w)) } static distanceManhattan(c, a) { return Math.sqrt(Math.abs(c.x - a.x) + Math.abs(c.y - a.y) + Math.abs(c.z - a.z) + Math.abs(c.w - a.w)) } static distanceMinkowski(c, a, b) { return (Math.abs(c.x - a.x) ** b + Math.abs(c.y - a.y) ** b + Math.abs(c.z - a.z) ** b + Math.abs(c.w - a.w) ** b) ** (1 / b) } static dot(c, a) { return c.x * a.x + c.y * a.y + c.z * a.z + c.w * a.w } static fromCopy(b) { return new Vec4({ ...b }.x, { ...b }.y, { ...b }.z, { ...b }.w) } static project(c, a) { const b = c.magnitude * Math.cos(Vec4.angleBetween(c, a)), d = Vec4.fromCopy(a); return d.normalize(), d.scale(b), d } static subtract(c, a) { return new Vec4(c.x - a.x, c.y - a.y, c.z - a.z, c.w - a.w) } get angleX() { return Math.atan2(Math.sqrt(this.y ** 2 + this.z ** 2), this.x) } get angleY() { return Math.atan2(Math.sqrt(this.x ** 2 + this.z ** 2), this.y) } get angleZ() { return Math.atan2(Math.sqrt(this.x ** 2 + this.y ** 2), this.z) } get magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } set limit(b) { this.magnitude > b && (this.normalize(), this.scale(b)) } set magnitude(b) { this.normalize(), this.scale(b) } add(b) { this.x += b.x, this.y += b.y, this.z += b.z, this.w += b.w } copy(b) { this.x = { ...b }.x, this.y = { ...b }.y, this.z = { ...b }.z, this.w = { ...b }.w } normalize() { let a = this.magnitude; 0 === a && (a = 1), this.x *= a, this.y *= a, this.z *= a, this.w *= a } scale(b) { this.x *= b, this.y *= b, this.z *= b, this.w *= b } subtract(b) { this.x -= b.x, this.y -= b.y, this.z -= b.z, this.w -= b.w } }