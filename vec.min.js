export class Vec2{constructor(x=0,y=0){this.x=x;this.y=y}static add(a,b){return new Vec2(a.x+b.x,a.y+b.y)}static angleBetween(a,b){return Math.atan2(b.y*a.x-b.x*a.y,b.x*a.x+b.y*a.y)}static clone(a){return new Vec2(a.x,a.y)}static distance(a,b){const ABX=a.x-b.x;const ABY=a.y-b.y;return Math.sqrt(ABX*ABX+ABY*ABY)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y}static equal(a,b){return a.x===b.x&&a.y===b.y}static fromCopy(a){return new Vec2(a.x,a.y)}static fromPolarCoords(r,phi){return new Vec2(r*Math.cos(phi),r*Math.sin(phi))}static lerp(a,b,t){if(t>1)t=1;else if(t<0)t=0;return new Vec2(a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t)}static project(a,b){return Vec2.clone(b).normalize().scale(a.magnitude*Math.cos(Vec2.angleBetween(a,b)))}static random(min=0,max=1){const R=min+Math.random()*(max-min);const PHI=Math.random()*Math.PI*2;return new Vec2(R*Math.cos(PHI),R*Math.sin(PHI))}static subtract(a,b){return new Vec2(a.x-b.x,a.y-b.y)}get angleX(){return Math.atan2(this.y,this.x)}get angleY(){return Math.atan2(this.x,this.y)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}get xy(){return[this.x,this.y]}set limit(max){if(this.magnitude>max){this.normalize();this.x*=max;this.y*=max}}set magnitude(m){this.normalize();this.x*=m;this.y*=m}set xy(xy){this.x=xy[0];this.y=xy[1]}add(a){this.x+=a.x;this.y+=a.y;return this}clamp(min,max){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x=a.x;this.y=a.y;return this}limitMaxMagnitude(max){const M=this.magnitude;if(M>max&&M>0){this.normalize();this.x*=max;this.y*=max}return this}limitMinMagnitude(min){const M=this.magnitude;if(M<min&&M>0){this.normalize();this.x*=min;this.y*=min}return this}normalize(){let m=this.magnitude;if(m===0)return this;else m=1/m;this.x*=m;this.y*=m;return this}rotateAxisZ(phi){[this.x,this.y]=[this.x*Math.cos(phi)+this.y*-Math.sin(phi),this.x*Math.sin(phi)+this.y*Math.cos(phi)];return this}scale(f){this.x*=f;this.y*=f;return this}subtract(a){this.x-=a.x;this.y-=a.y;return this}}export class Vec3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}static add(a,b){return new Vec3(a.x+b.x,a.y+b.y,a.z+b.z)}static angleBetween(a,b){const MA=a.magnitude;const MB=b.magnitude;if(MA===0||MB===0){console.error("Cannot divide by zero.");return NaN}return Math.acos((a.x*b.x+a.y*b.y+a.z*b.z)/(MA*MB))}static clone(a){return new Vec3(a.x,a.y,a.z)}static cross(a,b){return new Vec3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x)}static distance(a,b){const ABX=a.x-b.x;const ABY=a.y-b.y;const ABZ=a.z-b.z;return Math.sqrt(ABX*ABX+ABY*ABY+ABZ*ABZ)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y),Math.abs(a.z-b.z))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y)+Math.abs(a.z-b.z))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e+Math.abs(a.z-b.z)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z}static equal(a,b){return a.x===b.x&&a.y===b.y&&a.z===b.z}static fromCopy(a){return new Vec3(a.x,a.y,a.z)}static fromCylindricalCoords(r,phi,z){return new Vec3(r*Math.cos(phi),r*Math.sin(phi),z)}static fromSphericalCoords(r,phi,theta){return new Vec3(r*Math.sin(theta)*Math.cos(phi),r*Math.sin(theta)*Math.sin(phi),r*Math.cos(theta))}static lerp(a,b,t){if(t>1)t=1;else if(t<0)t=0;return new Vec3(a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t,a.z+(b.z-a.z)*t)}static project(a,b){return Vec3.clone(b).normalize().scale(a.magnitude*Math.cos(Vec3.angleBetween(a,b)))}static random(min=0,max=1){const R=min+Math.random()*(max-min);const PHI=Math.random()*Math.PI*2;const THETA=Math.random()*Math.PI;return new Vec3(R*Math.sin(THETA)*Math.cos(PHI),R*Math.sin(THETA)*Math.sin(PHI),R*Math.cos(THETA))}static subtract(a,b){return new Vec3(a.x-b.x,a.y-b.y,a.z-b.z)}get angleX(){return Math.atan2(Math.sqrt(this.y*this.y+this.z*this.z),this.x)}get angleY(){return Math.atan2(Math.sqrt(this.z*this.z+this.x*this.x),this.y)}get angleZ(){return Math.atan2(Math.sqrt(this.x*this.x+this.y*this.y),this.z)}get b(){return this.z}get g(){return this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}get r(){return this.x}get rgb(){return[this.x,this.y,this.z]}get xyz(){return[this.x,this.y,this.z]}set b(b){this.z=b}set g(g){this.y=g}set limit(max){if(this.magnitude>max){this.normalize();this.x*=max;this.y*=max;this.z*=max}}set magnitude(m){this.normalize();this.x*=m;this.y*=m;this.z*=m}set r(r){this.x=r}set rgb(rgb){this.x=rgb[0];this.y=rgb[1];this.z=rgb[2]}set xyz(xyz){this.x=xyz[0];this.y=xyz[1];this.z=xyz[2]}add(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;return this}clamp(min,max){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x=a.x;this.y=a.y;this.z=a.z;return this}limitMaxMagnitude(max){const M=this.magnitude;if(M>max&&M>0){this.normalize();this.x*=max;this.y*=max;this.z*=max}return this}limitMinMagnitude(min){const M=this.magnitude;if(M<min&&M>0){this.normalize();this.x*=min;this.y*=min;this.z*=min}return this}normalize(){let m=this.magnitude;if(m===0)return this;else m=1/m;this.x*=m;this.y*=m;this.z*=m;return this}rotateAxisX(phi){[this.y,this.z]=[this.y*Math.cos(phi)+this.z*-Math.sin(phi),this.y*Math.sin(phi)+this.z*Math.cos(phi)];return this}rotateAxisY(phi){[this.x,this.z]=[this.x*Math.cos(phi)+this.z*Math.sin(phi),this.x*-Math.sin(phi)+this.z*Math.cos(phi)];return this}rotateAxisZ(phi){[this.x,this.y]=[this.x*Math.cos(phi)+this.y*-Math.sin(phi),this.x*Math.sin(phi)+this.y*Math.cos(phi)];return this}scale(f){this.x*=f;this.y*=f;this.z*=f;return this}subtract(a){this.x-=a.x;this.y-=a.y;this.z-=a.z;return this}}export class Vec4{constructor(x=0,y=0,z=0,w=0){this.x=x;this.y=y;this.z=z;this.w=w}static add(a,b){return new Vec4(a.x+b.x,a.y+b.y,a.z+b.z,a.w+b.w)}static angleBetween(a,b){const MA=a.magnitude;const MB=b.magnitude;if(MA===0||MB===0){console.error("Cannot divide by zero.");return NaN}return Math.acos((a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w)/(MA*MB))}static clone(a){return new Vec4(a.x,a.y,a.z,a.w)}static distance(a,b){const ABX=a.x-b.x;const ABY=a.y-b.y;const ABZ=a.z-b.z;const ABW=a.w-b.w;return Math.sqrt(ABX*ABX+ABY*ABY+ABZ*ABZ+ABW*ABW)}static distanceChebyshev(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y),Math.abs(a.z-b.z),Math.abs(a.w-b.w))}static distanceManhattan(a,b){return Math.sqrt(Math.abs(a.x-b.x)+Math.abs(a.y-b.y)+Math.abs(a.z-b.z)+Math.abs(a.w-b.w))}static distanceMinkowski(a,b,e){if(e===0){console.error("Cannot divide by zero.");return NaN}return(Math.abs(a.x-b.x)**e+Math.abs(a.y-b.y)**e+Math.abs(a.z-b.z)**e+Math.abs(a.w-b.w)**e)**(1/e)}static dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w}static equal(a,b){return a.x===b.x&&a.y===b.y&&a.z===b.z&&a.w===b.w}static fromCopy(a){return new Vec4(a.x,a.y,a.z,a.w)}static lerp(a,b,t){if(t>1)t=1;else if(t<0)t=0;return new Vec4(a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t,a.z+(b.z-a.z)*t,a.w+(b.w-a.w)*t)}static project(a,b){return Vec4.clone(b).normalize().scale(a.magnitude*Math.cos(Vec4.angleBetween(a,b)))}static random(min=0,max=1){const A=-.5+Math.random();const B=-.5+Math.random();const C=-.5+Math.random();const D=-.5+Math.random();const SQRT=Math.sqrt((1-A*A-B*B)/(C*C+D*D));const V=new Vec4(A,B,C*SQRT,D*SQRT);V.magnitude=min+Math.random()*(max-min);return V}static subtract(a,b){return new Vec4(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w)}get a(){return this.w}get angleW(){return Math.atan2(Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z),this.w)}get angleX(){return Math.atan2(Math.sqrt(this.y*this.y+this.z*this.z+this.w*this.w),this.x)}get angleY(){return Math.atan2(Math.sqrt(this.z*this.z+this.w*this.w+this.x*this.x),this.y)}get angleZ(){return Math.atan2(Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y),this.z)}get b(){return this.z}get g(){return this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}get r(){return this.x}get rgba(){return[this.x,this.y,this.z,this.w]}get xyzw(){return[this.x,this.y,this.z,this.w]}set a(a){this.w=a}set b(b){this.z=b}set g(g){this.y=g}set limit(max){if(this.magnitude>max){this.normalize();this.x*=max;this.y*=max;this.z*=max;this.w*=max}}set magnitude(m){this.normalize();this.x*=m;this.y*=m;this.z*=m;this.w*=m}set r(r){this.x=r}set rgba(rgba){this.x=rgba[0];this.y=rgba[1];this.z=rgba[2];this.w=rgba[3]}set xyzw(xyzw){this.x=xyzw[0];this.y=xyzw[1];this.z=xyzw[2];this.w=xyzw[3]}add(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this}clamp(min,max){const M=this.magnitude;if(M>max)this.magnitude=max;else if(M<min)this.magnitude=min;return this}copy(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=a.w;return this}limitMaxMagnitude(max){const M=this.magnitude;if(M>max&&M>0){this.normalize();this.x*=max;this.y*=max;this.z*=max;this.w*=max}return this}limitMinMagnitude(min){const M=this.magnitude;if(M<min&&M>0){this.normalize();this.x*=min;this.y*=min;this.z*=min;this.w*=min}return this}normalize(){let m=this.magnitude;if(m===0)return this;else m=1/m;this.x*=m;this.y*=m;this.z*=m;this.w*=m;return this}scale(f){this.x*=f;this.y*=f;this.z*=f;this.w*=f;return this}subtract(a){this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this}}
