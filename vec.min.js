export class Vec2{constructor(t,s){this.x=t,this.y=s}static add(t,s){return new Vec2(t.x+s.x,t.y+s.y)}static angleBetween(t,s){const i=t.magnitude,a=s.magnitude;if(0!==i&&0!==a)return Math.acos(Vec2.dot(t,s)/(i*a))}static distance(t,s){const i=t.x-s.x,a=t.y-s.y;return Math.sqrt(i*i+a*a)}static distanceChebyshev(t,s){return Math.max(Math.abs(t.x-s.x),Math.abs(t.y-s.y))}static distanceManhattan(t,s){return Math.sqrt(Math.abs(t.x-s.x)+Math.abs(t.y-s.y))}static distanceMinkowski(t,s,i){return(Math.abs(t.x-s.x)**i+Math.abs(t.y-s.y)**i)**(1/i)}static dot(t,s){return t.x*s.x+t.y*s.y}static fromCopy(t){return new Vec2({...t}.x,{...t}.y)}static fromPolarCoords(t,s){return new Vec2(t*Math.cos(s),t*Math.sin(s))}static project(t,s){const i=t.magnitude*Math.cos(Vec2.angleBetween(t,s)),a=Vec2.fromCopy(s);return a.normalize(),a.scale(i),a}static subtract(t,s){return new Vec2(t.x-s.x,t.y-s.y)}get angleX(){return Math.atan2(this.y,this.x)}get angleY(){return Math.atan2(this.x,this.y)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}set limit(t){this.magnitude>t&&(this.normalize(),this.scale(t))}set magnitude(t){this.normalize(),this.scale(t)}add(t){this.x=this.x+t.x,this.y=this.y+t.y}copy(t){this.x={...t}.x,this.y={...t}.y}normalize(){let t=this.magnitude;0===t&&(t=1),this.x=this.x*t,this.y=this.y*t}scale(t){this.x=this.x*t,this.y=this.y*t}subtract(t){this.x=this.x-t.x,this.y=this.y-t.y}}export class Vec3{constructor(t,s,i){this.x=t,this.y=s,this.z=i}static add(t,s){return new Vec3(t.x+s.x,t.y+s.y,t.z+s.z)}static angleBetween(t,s){const i=t.magnitude,a=s.magnitude;if(0!==i&&0!==a)return Math.acos(Vec3.dot(t,s)/(i*a))}static cross(t,s){return new Vec3(t.y*s.z-s.y*t.z,t.z*s.x-s.z*t.x,t.x*s.y-s.x*t.y)}static distance(t,s){const i=t.x-s.x,a=t.y-s.y,h=t.z-s.z;return Math.sqrt(i*i+a*a+h*h)}static distanceChebyshev(t,s){return Math.max(Math.abs(t.x-s.x),Math.abs(t.y-s.y),Math.abs(t.z-s.z))}static distanceManhattan(t,s){return Math.sqrt(Math.abs(t.x-s.x)+Math.abs(t.y-s.y)+Math.abs(t.z-s.z))}static distanceMinkowski(t,s,i){return(Math.abs(t.x-s.x)**i+Math.abs(t.y-s.y)**i+Math.abs(t.z-s.z)**i)**(1/i)}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z}static fromCopy(t){return new Vec3({...t}.x,{...t}.y,{...t}.z)}static fromSphericalCoords(t,s,i){return new Vec3(t*Math.cos(s)*Math.sin(i),t*Math.sin(s)*Math.sin(i),t*Math.cos(i))}static project(t,s){const i=t.magnitude*Math.cos(Vec3.angleBetween(t,s)),a=Vec3.fromCopy(s);return a.normalize(),a.scale(i),a}static subtract(t,s){return new Vec3(t.x-s.x,t.y-s.y,t.z-s.z)}get angleX(){return Math.atan2(Math.sqrt(this.y**2+this.z**2),this.x)}get angleY(){return Math.atan2(Math.sqrt(this.x**2+this.z**2),this.y)}get angleZ(){return Math.atan2(Math.sqrt(this.x**2+this.y**2),this.z)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}set limit(t){this.magnitude>t&&(this.normalize(),this.scale(t))}set magnitude(t){this.normalize(),this.scale(t)}add(t){this.x=this.x+t.x,this.y=this.y+t.y,this.z=this.z+t.z}copy(t){this.x={...t}.x,this.y={...t}.y,this.z={...t}.z}normalize(){let t=this.magnitude;0===t&&(t=1),this.x=this.x*t,this.y=this.y*t,this.z=this.z*t}scale(t){this.x=this.x*t,this.y=this.y*t,this.z=this.z*t}subtract(t){this.x=this.x-t.x,this.y=this.y-t.y,this.z=this.z-t.z}}export class Vec4{constructor(t,s,i,a){this.x=t,this.y=s,this.z=i,this.w=a}static add(t,s){return new Vec4(t.x+s.x,t.y+s.y,t.z+s.z,t.w+s.w)}static angleBetween(t,s){const i=t.magnitude,a=s.magnitude;if(0!==i&&0!==a)return Math.acos(Vec4.dot(t,s)/(i*a))}static distance(t,s){const i=t.x-s.x,a=t.y-s.y,h=t.z-s.z,e=t.w-s.w;return Math.sqrt(i*i+a*a+h*h+e*e)}static distanceChebyshev(t,s){return Math.max(Math.abs(t.x-s.x),Math.abs(t.y-s.y),Math.abs(t.z-s.z),Math.abs(t.w-s.w))}static distanceManhattan(t,s){return Math.sqrt(Math.abs(t.x-s.x)+Math.abs(t.y-s.y)+Math.abs(t.z-s.z)+Math.abs(t.w-s.w))}static distanceMinkowski(t,s,i){return(Math.abs(t.x-s.x)**i+Math.abs(t.y-s.y)**i+Math.abs(t.z-s.z)**i+Math.abs(t.w-s.w)**i)**(1/i)}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}static fromCopy(t){return new Vec4({...t}.x,{...t}.y,{...t}.z,{...t}.w)}static project(t,s){const i=t.magnitude*Math.cos(Vec4.angleBetween(t,s)),a=Vec4.fromCopy(s);return a.normalize(),a.scale(i),a}static subtract(t,s){return new Vec4(t.x-s.x,t.y-s.y,t.z-s.z,t.w-s.w)}get angleX(){return Math.atan2(Math.sqrt(this.y**2+this.z**2),this.x)}get angleY(){return Math.atan2(Math.sqrt(this.x**2+this.z**2),this.y)}get angleZ(){return Math.atan2(Math.sqrt(this.x**2+this.y**2),this.z)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}set limit(t){this.magnitude>t&&(this.normalize(),this.scale(t))}set magnitude(t){this.normalize(),this.scale(t)}add(t){this.x=this.x+t.x,this.y=this.y+t.y,this.z=this.z+t.z,this.w=this.w+t.w}copy(t){this.x={...t}.x,this.y={...t}.y,this.z={...t}.z,this.w={...t}.w}normalize(){let t=this.magnitude;0===t&&(t=1),this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t}scale(t){this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t}subtract(t){this.x=this.x-t.x,this.y=this.y-t.y,this.z=this.z-t.z,this.w=this.w-t.w}}